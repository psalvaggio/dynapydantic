{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"dynapydantic","text":"<p><code>dynapydantic</code> is an extension to the pydantic Python package that allow for dynamic tracking of <code>pydantic.BaseModel</code> subclasses.</p>"},{"location":"#installation","title":"Installation","text":"<p>This project can be installed via PyPI: <pre><code>pip install dynapydantic\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#trackinggroup","title":"<code>TrackingGroup</code>","text":"<p>The core entity in this library is the <code>dynapydantic.TrackingGroup</code>: <pre><code>import typing as ty\n\nimport dynapydantic\nimport pydantic\n\nmygroup = dynapydantic.TrackingGroup(\n    name=\"mygroup\",\n    discriminator_field=\"name\"\n)\n\n@mygroup.register(\"A\")\nclass A(pydantic.BaseModel):\n    \"\"\"A class to be tracked, will be tracked as \"A\".\"\"\"\n    a: int\n\n@mygroup.register()\nclass B(pydantic.BaseModel):\n    \"\"\"Another class, will be tracked as \"B\".\"\"\"\n    name: ty.Literal[\"B\"] = \"B\"\n    a: int\n\nclass Model(pydantic.BaseModel):\n    \"\"\"A model that can have A or B\"\"\"\n    field: mygroup.union()  # call after all subclasses have been registered\n\nprint(Model(field={\"name\": \"A\", \"a\": 4})) # field=A(a=4, name='A')\nprint(Model(field={\"name\": \"B\", \"a\": 5})) # field=B(name='B', a=5)\n</code></pre></p> <p>The <code>union()</code> method produces a discriminated union of all registered <code>pydantic.BaseModel</code> subclasses. It also accepts an <code>annotated=False</code> keyword argument to produce a plain <code>typing.Union</code> for use in type annotations. This union is based on a discriminator field, which was configured by the <code>discriminator_field</code> argument to <code>TrackingGroup</code>. The field can be created by hand, as was shown with <code>B</code>, or <code>dynapydantic</code> will inject it for you, as was shown with <code>A</code>.</p> <p><code>TrackingGroup</code> has a few opt-in features to make it more powerful and easier to use: 1. <code>discriminator_value_generator</code>: This parameter is a optional callback   function that is called with each class that gets registered and produces a   default value for the discriminator field. This allows the user to call   <code>register()</code> without a value for the discriminator. The most common value to   pass here would be <code>lambda cls: cls.__name__</code>, to use the name of the class as   the discriminator value. 2. <code>plugin_entry_point</code>: This parameter indicates to <code>dynapydantic</code> that there   might be models to be discovered in other packages. Packages are discovered by   the Python entrypoint mechanism. See the <code>tests/example</code> directory for an   example of how this works.</p>"},{"location":"#subclasstrackingmodel","title":"<code>SubclassTrackingModel</code>","text":"<p>The most common use case of this pattern is to automatically register subclasses of a given <code>pydantic.BaseModel</code>. This is supported via the use of <code>dynapydantic.SubclassTrackingModel</code>. For example: <pre><code>import typing as ty\n\nimport dynapydantic\nimport pydantic\n\nclass Base(\n    dynapydantic.SubclassTrackingModel,\n    discriminator_field=\"name\",\n    discriminator_value_generator=lambda cls: cls.__name__,\n):\n    \"\"\"Base model, will track its subclasses\"\"\"\n\n    # The TrackingGroup can be specified here like model_config, or passed in\n    # kwargs of the class declaration, just like how model_config works with\n    # pydantic.BaseModel. If you do it like this, you have to give the tracking\n    # group a name\n    # tracking_config: ty.ClassVar[dynapydantic.TrackingGroup] = dynapydantic.TrackingGroup(\n    #     name=\"BaseSubclasses\",\n    #     discriminator_field=\"name\",\n    #     discriminator_value_generator=lambda cls: cls.__name__,\n    # )\n\n\nclass Intermediate(Base, exclude_from_union=True):\n    \"\"\"Subclasses can opt out of being tracked\"\"\"\n\nclass Derived1(Intermediate):\n    \"\"\"Non-direct descendants are registered\"\"\"\n    a: int\n\nclass Derived2(Intermediate):\n    \"\"\"You can override the value generator if desired\"\"\"\n    name: ty.Literal[\"Custom\"] = \"Custom\"\n    a: int\n\nprint(Base.registered_subclasses())\n# {'Derived1': &lt;class '__main__.Derived1'&gt;, 'Custom': &lt;class '__main__.Derived2'&gt;}\n\n# if plugin_entry_point was specificed, load plugin packages\n# Base.load_plugins()\n\nclass Model(pydantic.BaseModel):\n    \"\"\"A model that can have any registered Base subclass\"\"\"\n    field: Base.union()  # call after all subclasses have been registered\n\nprint(Model(field={\"name\": \"Derived1\", \"a\": 4}))\n# field=Derived1(a=4, name='Derived1')\nprint(Model(field={\"name\": \"Custom\", \"a\": 5}))\n# field=Derived2(name='Custom', a=5)\n</code></pre></p>"},{"location":"reference/","title":"API Reference","text":"<p>dynapydantic - dynamic tracking of pydantic models</p>"},{"location":"reference/#dynapydantic.AmbiguousDiscriminatorValueError","title":"<code>AmbiguousDiscriminatorValueError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Occurs when the discriminator value is ambiguous</p> Source code in <code>src/dynapydantic/exceptions.py</code> <pre><code>class AmbiguousDiscriminatorValueError(Error):\n    \"\"\"Occurs when the discriminator value is ambiguous\"\"\"\n</code></pre>"},{"location":"reference/#dynapydantic.ConfigurationError","title":"<code>ConfigurationError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Occurs when the user misconfigured a tracking setup</p> Source code in <code>src/dynapydantic/exceptions.py</code> <pre><code>class ConfigurationError(Error):\n    \"\"\"Occurs when the user misconfigured a tracking setup\"\"\"\n</code></pre>"},{"location":"reference/#dynapydantic.Error","title":"<code>Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all dynapydanitc errors</p> Source code in <code>src/dynapydantic/exceptions.py</code> <pre><code>class Error(Exception):\n    \"\"\"Base class for all dynapydanitc errors\"\"\"\n</code></pre>"},{"location":"reference/#dynapydantic.RegistrationError","title":"<code>RegistrationError</code>","text":"<p>               Bases: <code>Error</code></p> <p>Occurs when a model cannot be registered</p> Source code in <code>src/dynapydantic/exceptions.py</code> <pre><code>class RegistrationError(Error):\n    \"\"\"Occurs when a model cannot be registered\"\"\"\n</code></pre>"},{"location":"reference/#dynapydantic.SubclassTrackingModel","title":"<code>SubclassTrackingModel</code>  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Subclass-tracking BaseModel</p> Source code in <code>src/dynapydantic/subclass_tracking_model.py</code> <pre><code>class SubclassTrackingModel(pydantic.BaseModel):\n    \"\"\"Subclass-tracking BaseModel\"\"\"\n\n    def __init_subclass__(\n        cls,\n        *args,\n        exclude_from_union: bool | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Subclass hook\"\"\"\n        # Intercept any kwargs that are intended for TrackingGroup\n        super().__pydantic_init_subclass__(\n            *args,\n            **{k: v for k, v in kwargs.items() if k not in TrackingGroup.model_fields},\n        )\n\n    @classmethod\n    def __pydantic_init_subclass__(\n        cls,\n        *args,\n        exclude_from_union: bool | None = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Pydantic subclass hook\"\"\"\n        if SubclassTrackingModel in cls.__bases__:\n            # Intercept any kwargs that are intended for TrackingGroup\n            super().__pydantic_init_subclass__(\n                *args,\n                **{\n                    k: v\n                    for k, v in kwargs.items()\n                    if k not in TrackingGroup.model_fields\n                },\n            )\n\n            if isinstance(getattr(cls, \"tracking_config\", None), TrackingGroup):\n                cls.__DYNAPYDANTIC__ = cls.tracking_config\n            else:\n                try:\n                    cls.__DYNAPYDANTIC__: TrackingGroup = TrackingGroup.model_validate(\n                        {\"name\": f\"{cls.__name__}-subclasses\"} | kwargs,\n                    )\n                except pydantic.ValidationError as e:\n                    msg = (\n                        \"SubclassTrackingModel subclasses must either have a \"\n                        \"tracking_config: ClassVar[dynapydantic.TrackingGroup] \"\n                        \"member or pass kwargs sufficient to construct a \"\n                        \"dynapydantic.TrackingGroup in the class declaration. \"\n                        \"The latter approach produced the following \"\n                        f\"ValidationError:\\n{e}\"\n                    )\n                    raise ConfigurationError(msg) from e\n\n            # Promote the tracking group's methods to the parent class\n            if cls.__DYNAPYDANTIC__.plugin_entry_point is not None:\n\n                def _load_plugins() -&gt; None:\n                    \"\"\"Load plugins to register more models\"\"\"\n                    cls.__DYNAPYDANTIC__.load_plugins()\n\n                cls.load_plugins = staticmethod(_load_plugins)\n\n            def _union(*, annotated: bool = True) -&gt; ty.GenericAlias:\n                \"\"\"Get the union of all tracked subclasses\n\n                Parameters\n                ----------\n                annotated\n                    Whether this should be an annotated union for usage as a\n                    pydantic field annotation, or a plain typing.Union for a\n                    regular type annotation.\n                \"\"\"\n                return cls.__DYNAPYDANTIC__.union(annotated=annotated)\n\n            cls.union = staticmethod(_union)\n\n            def _subclasses() -&gt; dict[str, type[cls]]:\n                \"\"\"Return a mapping of discriminator values to registered model\"\"\"\n                return cls.__DYNAPYDANTIC__.models\n\n            cls.registered_subclasses = staticmethod(_subclasses)\n\n            return\n\n        super().__pydantic_init_subclass__(*args, **kwargs)\n\n        if exclude_from_union:\n            return\n\n        supers = direct_children_of_base_in_mro(cls, SubclassTrackingModel)\n        for base in supers:\n            base.__DYNAPYDANTIC__.register_model(cls)\n</code></pre>"},{"location":"reference/#dynapydantic.SubclassTrackingModel.__init_subclass__","title":"<code>__init_subclass__(*args, exclude_from_union=None, **kwargs)</code>","text":"<p>Subclass hook</p> Source code in <code>src/dynapydantic/subclass_tracking_model.py</code> <pre><code>def __init_subclass__(\n    cls,\n    *args,\n    exclude_from_union: bool | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Subclass hook\"\"\"\n    # Intercept any kwargs that are intended for TrackingGroup\n    super().__pydantic_init_subclass__(\n        *args,\n        **{k: v for k, v in kwargs.items() if k not in TrackingGroup.model_fields},\n    )\n</code></pre>"},{"location":"reference/#dynapydantic.SubclassTrackingModel.__pydantic_init_subclass__","title":"<code>__pydantic_init_subclass__(*args, exclude_from_union=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Pydantic subclass hook</p> Source code in <code>src/dynapydantic/subclass_tracking_model.py</code> <pre><code>@classmethod\ndef __pydantic_init_subclass__(\n    cls,\n    *args,\n    exclude_from_union: bool | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Pydantic subclass hook\"\"\"\n    if SubclassTrackingModel in cls.__bases__:\n        # Intercept any kwargs that are intended for TrackingGroup\n        super().__pydantic_init_subclass__(\n            *args,\n            **{\n                k: v\n                for k, v in kwargs.items()\n                if k not in TrackingGroup.model_fields\n            },\n        )\n\n        if isinstance(getattr(cls, \"tracking_config\", None), TrackingGroup):\n            cls.__DYNAPYDANTIC__ = cls.tracking_config\n        else:\n            try:\n                cls.__DYNAPYDANTIC__: TrackingGroup = TrackingGroup.model_validate(\n                    {\"name\": f\"{cls.__name__}-subclasses\"} | kwargs,\n                )\n            except pydantic.ValidationError as e:\n                msg = (\n                    \"SubclassTrackingModel subclasses must either have a \"\n                    \"tracking_config: ClassVar[dynapydantic.TrackingGroup] \"\n                    \"member or pass kwargs sufficient to construct a \"\n                    \"dynapydantic.TrackingGroup in the class declaration. \"\n                    \"The latter approach produced the following \"\n                    f\"ValidationError:\\n{e}\"\n                )\n                raise ConfigurationError(msg) from e\n\n        # Promote the tracking group's methods to the parent class\n        if cls.__DYNAPYDANTIC__.plugin_entry_point is not None:\n\n            def _load_plugins() -&gt; None:\n                \"\"\"Load plugins to register more models\"\"\"\n                cls.__DYNAPYDANTIC__.load_plugins()\n\n            cls.load_plugins = staticmethod(_load_plugins)\n\n        def _union(*, annotated: bool = True) -&gt; ty.GenericAlias:\n            \"\"\"Get the union of all tracked subclasses\n\n            Parameters\n            ----------\n            annotated\n                Whether this should be an annotated union for usage as a\n                pydantic field annotation, or a plain typing.Union for a\n                regular type annotation.\n            \"\"\"\n            return cls.__DYNAPYDANTIC__.union(annotated=annotated)\n\n        cls.union = staticmethod(_union)\n\n        def _subclasses() -&gt; dict[str, type[cls]]:\n            \"\"\"Return a mapping of discriminator values to registered model\"\"\"\n            return cls.__DYNAPYDANTIC__.models\n\n        cls.registered_subclasses = staticmethod(_subclasses)\n\n        return\n\n    super().__pydantic_init_subclass__(*args, **kwargs)\n\n    if exclude_from_union:\n        return\n\n    supers = direct_children_of_base_in_mro(cls, SubclassTrackingModel)\n    for base in supers:\n        base.__DYNAPYDANTIC__.register_model(cls)\n</code></pre>"},{"location":"reference/#dynapydantic.TrackingGroup","title":"<code>TrackingGroup</code>  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Tracker for pydantic models</p> <p>Fields:</p> <ul> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>discriminator_field</code>                 (<code>str</code>)             </li> <li> <code>plugin_entry_point</code>                 (<code>str | None</code>)             </li> <li> <code>discriminator_value_generator</code>                 (<code>Callable[[type], str] | None</code>)             </li> <li> <code>models</code>                 (<code>dict[str, type[BaseModel]]</code>)             </li> </ul> Source code in <code>src/dynapydantic/tracking_group.py</code> <pre><code>class TrackingGroup(pydantic.BaseModel):\n    \"\"\"Tracker for pydantic models\"\"\"\n\n    name: str = pydantic.Field(\n        description=(\n            \"Name of the tracking group. This is for human display, so it \"\n            \"doesn't technically need to be globally unique, but it should be \"\n            \"meaningfully named, as it will be used in error messages.\"\n        ),\n    )\n    discriminator_field: str = pydantic.Field(\n        description=\"Name of the discriminator field\",\n    )\n    plugin_entry_point: str | None = pydantic.Field(\n        None,\n        description=(\n            \"If given, then plugins packages will be supported through this \"\n            \"Python entrypoint. The entrypoint can either be a function, \"\n            \"which will be called, or simply a module, which will be \"\n            \"imported. In either case, models found along the import path of \"\n            \"the entrypoint will be registered. If the entrypoint is a \"\n            \"function, additional models may be declared in the function.\"\n        ),\n    )\n    discriminator_value_generator: ty.Callable[[type], str] | None = pydantic.Field(\n        None,\n        description=(\n            \"A callable that produces default values for the discriminator field\"\n        ),\n    )\n    models: dict[str, type[pydantic.BaseModel]] = pydantic.Field(\n        {},\n        description=\"The tracked models\",\n    )\n\n    def load_plugins(self) -&gt; None:\n        \"\"\"Load plugins to discover/register additional models\"\"\"\n        if self.plugin_entry_point is None:\n            return\n\n        from importlib.metadata import entry_points  # noqa: PLC0415\n\n        for ep in entry_points().select(group=self.plugin_entry_point):\n            plugin = ep.load()\n            if callable(plugin):\n                plugin()\n\n    def register(\n        self,\n        discriminator_value: str | None = None,\n    ) -&gt; ty.Callable[[type], type]:\n        \"\"\"Register a model into this group (decorator)\n\n        Parameters\n        ----------\n        discriminator_value\n            Value for the discriminator field. If not given, then\n            discriminator_value_generator must be non-None or the\n            discriminator field must be declared by hand.\n        \"\"\"\n\n        def _wrapper(cls: type[pydantic.BaseModel]) -&gt; None:\n            disc = self.discriminator_field\n            field = cls.model_fields.get(self.discriminator_field)\n            if field is None:\n                if discriminator_value is not None:\n                    _inject_discriminator_field(cls, disc, discriminator_value)\n                elif self.discriminator_value_generator is not None:\n                    _inject_discriminator_field(\n                        cls,\n                        disc,\n                        self.discriminator_value_generator(cls),\n                    )\n                else:\n                    msg = (\n                        f\"unable to determine a discriminator value for \"\n                        f'{cls.__name__} in tracking group \"{self.name}\". No '\n                        \"value was passed to register(), \"\n                        \"discriminator_value_generator was None and the \"\n                        f'\"{disc}\" field was not defined.'\n                    )\n                    raise RegistrationError(msg)\n            elif (\n                discriminator_value is not None and field.default != discriminator_value\n            ):\n                msg = (\n                    f\"the discriminator value for {cls.__name__} was \"\n                    f'ambiguous, it was set to \"{discriminator_value}\" via '\n                    f'register() and \"{field.default}\" via the discriminator '\n                    f\"field ({self.discriminator_field}).\"\n                )\n                raise AmbiguousDiscriminatorValueError(msg)\n\n            self._register_with_discriminator_field(cls)\n            return cls\n\n        return _wrapper\n\n    def register_model(self, cls: type[pydantic.BaseModel]) -&gt; None:\n        \"\"\"Register the given model into this group\n\n        Parameters\n        ----------\n        cls\n            The model to register\n        \"\"\"\n        disc = self.discriminator_field\n        if cls.model_fields.get(self.discriminator_field) is None:\n            if self.discriminator_value_generator is not None:\n                _inject_discriminator_field(\n                    cls,\n                    disc,\n                    self.discriminator_value_generator(cls),\n                )\n            else:\n                msg = (\n                    f\"unable to determine a discriminator value for \"\n                    f'{cls.__name__} in tracking group \"{self.name}\", '\n                    \"discriminator_value_generator was None and the \"\n                    f'\"{disc}\" field was not defined.'\n                )\n                raise RegistrationError(msg)\n\n        self._register_with_discriminator_field(cls)\n\n    def _register_with_discriminator_field(self, cls: type[pydantic.BaseModel]) -&gt; None:\n        \"\"\"Register the model with the default of the discriminator field\n\n        Parameters\n        ----------\n        cls\n            The class to register, must have the disciminator field set with a\n            unique default value in the group.\n        \"\"\"\n        disc = self.discriminator_field\n        field = cls.model_fields.get(disc)\n        value = field.default\n        if value == pydantic_core.PydanticUndefined:\n            msg = (\n                f\"{cls.__name__}.{disc} had no default value, it must \"\n                \"have one which is unique among all tracked models.\"\n            )\n            raise RegistrationError(msg)\n\n        if (other := self.models.get(value)) is not None and other is not cls:\n            msg = (\n                f'Cannot register {cls.__name__} under the \"{value}\" '\n                f\"identifier, which is already in use by {other.__name__}.\"\n            )\n            raise RegistrationError(msg)\n\n        self.models[value] = cls\n\n    def union(self, *, annotated: bool = True) -&gt; ty.GenericAlias:\n        \"\"\"Return the union of all registered models\"\"\"\n        return (\n            ty.Annotated[\n                ty.Union[  # noqa: UP007\n                    tuple(\n                        ty.Annotated[x, pydantic.Tag(v)] for v, x in self.models.items()\n                    )\n                ],\n                pydantic.Field(discriminator=self.discriminator_field),\n            ]\n            if annotated\n            else ty.Union[tuple(self.models.values())]  # noqa: UP007\n        )\n</code></pre>"},{"location":"reference/#dynapydantic.TrackingGroup.discriminator_field","title":"<code>discriminator_field</code>  <code>pydantic-field</code>","text":"<p>Name of the discriminator field</p>"},{"location":"reference/#dynapydantic.TrackingGroup.discriminator_value_generator","title":"<code>discriminator_value_generator = None</code>  <code>pydantic-field</code>","text":"<p>A callable that produces default values for the discriminator field</p>"},{"location":"reference/#dynapydantic.TrackingGroup.models","title":"<code>models = {}</code>  <code>pydantic-field</code>","text":"<p>The tracked models</p>"},{"location":"reference/#dynapydantic.TrackingGroup.name","title":"<code>name</code>  <code>pydantic-field</code>","text":"<p>Name of the tracking group. This is for human display, so it doesn't technically need to be globally unique, but it should be meaningfully named, as it will be used in error messages.</p>"},{"location":"reference/#dynapydantic.TrackingGroup.plugin_entry_point","title":"<code>plugin_entry_point = None</code>  <code>pydantic-field</code>","text":"<p>If given, then plugins packages will be supported through this Python entrypoint. The entrypoint can either be a function, which will be called, or simply a module, which will be imported. In either case, models found along the import path of the entrypoint will be registered. If the entrypoint is a function, additional models may be declared in the function.</p>"},{"location":"reference/#dynapydantic.TrackingGroup.load_plugins","title":"<code>load_plugins()</code>","text":"<p>Load plugins to discover/register additional models</p> Source code in <code>src/dynapydantic/tracking_group.py</code> <pre><code>def load_plugins(self) -&gt; None:\n    \"\"\"Load plugins to discover/register additional models\"\"\"\n    if self.plugin_entry_point is None:\n        return\n\n    from importlib.metadata import entry_points  # noqa: PLC0415\n\n    for ep in entry_points().select(group=self.plugin_entry_point):\n        plugin = ep.load()\n        if callable(plugin):\n            plugin()\n</code></pre>"},{"location":"reference/#dynapydantic.TrackingGroup.register","title":"<code>register(discriminator_value=None)</code>","text":"<p>Register a model into this group (decorator)</p> <p>Parameters:</p> Name Type Description Default <code>discriminator_value</code> <code>str | None</code> <p>Value for the discriminator field. If not given, then discriminator_value_generator must be non-None or the discriminator field must be declared by hand.</p> <code>None</code> Source code in <code>src/dynapydantic/tracking_group.py</code> <pre><code>def register(\n    self,\n    discriminator_value: str | None = None,\n) -&gt; ty.Callable[[type], type]:\n    \"\"\"Register a model into this group (decorator)\n\n    Parameters\n    ----------\n    discriminator_value\n        Value for the discriminator field. If not given, then\n        discriminator_value_generator must be non-None or the\n        discriminator field must be declared by hand.\n    \"\"\"\n\n    def _wrapper(cls: type[pydantic.BaseModel]) -&gt; None:\n        disc = self.discriminator_field\n        field = cls.model_fields.get(self.discriminator_field)\n        if field is None:\n            if discriminator_value is not None:\n                _inject_discriminator_field(cls, disc, discriminator_value)\n            elif self.discriminator_value_generator is not None:\n                _inject_discriminator_field(\n                    cls,\n                    disc,\n                    self.discriminator_value_generator(cls),\n                )\n            else:\n                msg = (\n                    f\"unable to determine a discriminator value for \"\n                    f'{cls.__name__} in tracking group \"{self.name}\". No '\n                    \"value was passed to register(), \"\n                    \"discriminator_value_generator was None and the \"\n                    f'\"{disc}\" field was not defined.'\n                )\n                raise RegistrationError(msg)\n        elif (\n            discriminator_value is not None and field.default != discriminator_value\n        ):\n            msg = (\n                f\"the discriminator value for {cls.__name__} was \"\n                f'ambiguous, it was set to \"{discriminator_value}\" via '\n                f'register() and \"{field.default}\" via the discriminator '\n                f\"field ({self.discriminator_field}).\"\n            )\n            raise AmbiguousDiscriminatorValueError(msg)\n\n        self._register_with_discriminator_field(cls)\n        return cls\n\n    return _wrapper\n</code></pre>"},{"location":"reference/#dynapydantic.TrackingGroup.register_model","title":"<code>register_model(cls)</code>","text":"<p>Register the given model into this group</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[BaseModel]</code> <p>The model to register</p> required Source code in <code>src/dynapydantic/tracking_group.py</code> <pre><code>def register_model(self, cls: type[pydantic.BaseModel]) -&gt; None:\n    \"\"\"Register the given model into this group\n\n    Parameters\n    ----------\n    cls\n        The model to register\n    \"\"\"\n    disc = self.discriminator_field\n    if cls.model_fields.get(self.discriminator_field) is None:\n        if self.discriminator_value_generator is not None:\n            _inject_discriminator_field(\n                cls,\n                disc,\n                self.discriminator_value_generator(cls),\n            )\n        else:\n            msg = (\n                f\"unable to determine a discriminator value for \"\n                f'{cls.__name__} in tracking group \"{self.name}\", '\n                \"discriminator_value_generator was None and the \"\n                f'\"{disc}\" field was not defined.'\n            )\n            raise RegistrationError(msg)\n\n    self._register_with_discriminator_field(cls)\n</code></pre>"},{"location":"reference/#dynapydantic.TrackingGroup.union","title":"<code>union(*, annotated=True)</code>","text":"<p>Return the union of all registered models</p> Source code in <code>src/dynapydantic/tracking_group.py</code> <pre><code>def union(self, *, annotated: bool = True) -&gt; ty.GenericAlias:\n    \"\"\"Return the union of all registered models\"\"\"\n    return (\n        ty.Annotated[\n            ty.Union[  # noqa: UP007\n                tuple(\n                    ty.Annotated[x, pydantic.Tag(v)] for v, x in self.models.items()\n                )\n            ],\n            pydantic.Field(discriminator=self.discriminator_field),\n        ]\n        if annotated\n        else ty.Union[tuple(self.models.values())]  # noqa: UP007\n    )\n</code></pre>"}]}